"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[3179],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}},8635:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sdk/rust/sdk-rust-high-level-sdk","title":"High-level SDK","description":"If you\'ve read through the getting started guide, you might have noticed that it\'s quite verbose and requires a lot of boilerplate code to get started. This is where the High-level SDK comes in, as it does provide a more user-friendly interface to interact with the Iggy API for both, producer and consumer. Let\'s consider the following features:","source":"@site/docs/sdk/rust/high_level_sdk.md","sourceDirName":"sdk/rust","slug":"/sdk/rust/high-level-sdk","permalink":"/docs/sdk/rust/high-level-sdk","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"sdk-rust-high-level-sdk","slug":"/sdk/rust/high-level-sdk","title":"High-level SDK","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Examples","permalink":"/docs/sdk/rust/examples"},"next":{"title":"Stream Builder","permalink":"/docs/sdk/rust/stream-builder"}}');var i=n(4848),o=n(8453);const r={id:"sdk-rust-high-level-sdk",slug:"/sdk/rust/high-level-sdk",title:"High-level SDK",sidebar_position:3},c=void 0,l={},d=[{value:"Connection string",id:"connection-string",level:2},{value:"Producer",id:"producer",level:2},{value:"Consumer",id:"consumer",level:2}];function a(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["If you've read through the ",(0,i.jsx)(t.a,{href:"/docs/introduction/getting-started",children:"getting started"})," guide, you might have noticed that it's quite verbose and requires a lot of boilerplate code to get started. This is where the High-level SDK comes in, as it does provide a more user-friendly interface to interact with the Iggy API for both, producer and consumer. Let's consider the following features:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Automatically creating & joining the consumer groups"}),"\n",(0,i.jsx)(t.li,{children:"Committing the offset depending on the particular mode (e.g. in the background based on some interval, after polling N messages etc.)"}),"\n",(0,i.jsx)(t.li,{children:"Batching the messages, whether it's about producing or consuming"}),"\n",(0,i.jsx)(t.li,{children:"Processing the messages as if the stream was an async iterator"}),"\n",(0,i.jsx)(t.li,{children:"Reusing the same client for both, producing and consuming on the same topic without repeating the configuration"}),"\n",(0,i.jsx)(t.li,{children:"And more..."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"connection-string",children:"Connection string"}),"\n",(0,i.jsx)(t.p,{children:"Instead of providing the configuration for the client, you can use the connection string. It's a string that contains all the necessary information to connect to the Iggy API with only a single caveat, as it does support TCP protocol only for now. Here's the basic example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"iggy://iggy:secret@localhost:3050\n"})}),"\n",(0,i.jsx)(t.p,{children:"Which can be used to create the client like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'let client = IggyClient::from_connection_string("iggy://iggy:secret@localhost:3050")?;\n'})}),"\n",(0,i.jsxs)(t.p,{children:["By default, the connection string will use TCP transport protocol, but you can also specify the other one by including ",(0,i.jsx)(t.code,{children:"+{protocol}"})," to the initial ",(0,i.jsx)(t.code,{children:"iggy"})," part, for example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"iggy+tcp://iggy:secret@localhost:3050\niggy+quic://iggy:secret@localhost:3050\niggy+http://iggy:secret@localhost:3050\n"})}),"\n",(0,i.jsx)(t.p,{children:"And here's the full example of TCP connection string with its all optional parts:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"iggy://iggy:secret@localhost:3050?tls=true&tls_domain=test.com&reconnection_retries=5&reconnection_interval=5s&reestablish_after=10s&heartbeat_interval=3s&nodelay=true\n"})}),"\n",(0,i.jsxs)(t.p,{children:["By default, the ",(0,i.jsx)(t.strong,{children:"TCP"})," connection string is parsed with the following options:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tls"})," - whether to use the TLS connection or not (default: ",(0,i.jsx)(t.code,{children:"false"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tls_domain"})," - the domain to use for the TLS connection (default: ",(0,i.jsx)(t.code,{children:"None"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tls_ca_file"})," - the path to the CA file to use for the TLS connection (default: ",(0,i.jsx)(t.code,{children:"None"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reconnection_retries"})," - the number of retries to establish the connection (default: ",(0,i.jsx)(t.code,{children:"unlimited"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reconnection_interval"})," - the interval between the reconnection attempts (default: ",(0,i.jsx)(t.code,{children:"1s"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reestablish_after"})," - the time to wait before reestablishing the connection (default: ",(0,i.jsx)(t.code,{children:"5s"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"heartbeat_interval"})," - the interval between the heartbeat messages (default: ",(0,i.jsx)(t.code,{children:"5s"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"nodelay"})," - whether to use the TCP_NODELAY option or not (default: ",(0,i.jsx)(t.code,{children:"false"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.strong,{children:"QUIC"}),", the connection string is parsed with the following options:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"response_buffer_size"})," - the size of the response buffer (default: ",(0,i.jsx)(t.code,{children:"10_000_000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"max_concurrent_bidi_streams"})," - the maximum number of concurrent bidirectional streams (default: ",(0,i.jsx)(t.code,{children:"10000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"datagram_send_buffer_size"})," - the size of the datagram send buffer (default: ",(0,i.jsx)(t.code,{children:"100_000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"initial_mtu"})," - the initial MTU size (default: ",(0,i.jsx)(t.code,{children:"1200"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"send_window"})," - the size of the send window (default: ",(0,i.jsx)(t.code,{children:"100_000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"receive_window"})," - the size of the receive window (default: ",(0,i.jsx)(t.code,{children:"100_000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"keep_alive_interval"})," - the interval between the keep-alive messages (default: ",(0,i.jsx)(t.code,{children:"5000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"max_idle_timeout"})," - the maximum idle timeout (default: ",(0,i.jsx)(t.code,{children:"10000"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"validate_certificate"})," - whether to validate the server certificate or not (default: ",(0,i.jsx)(t.code,{children:"false"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reconnection_retries"})," - the number of retries to establish the connection (default: ",(0,i.jsx)(t.code,{children:"unlimited"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reconnection_interval"})," - the interval between the reconnection attempts (default: ",(0,i.jsx)(t.code,{children:"1s"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"reestablish_after"})," - the time to wait before reestablishing the connection (default: ",(0,i.jsx)(t.code,{children:"5s"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"heartbeat_interval"})," - the interval between the heartbeat messages (default: ",(0,i.jsx)(t.code,{children:"5s"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Unless you need to provide a specific implementation of the client-side ",(0,i.jsx)(t.code,{children:"Encryptor"}),", ",(0,i.jsx)(t.code,{children:"Partitioner"})," or adjust some other settings, you should be good to go with the connection string. On the other hand, you can always make use of ",(0,i.jsx)(t.code,{children:"IggyClientBuilder::from_connection_string()"})," to extend the options on top of the provided connection string."]}),"\n",(0,i.jsxs)(t.p,{children:["Additionally, if you were to check the internal implementation of ",(0,i.jsx)(t.code,{children:"IggyClient"}),", you'd notice that it does use ",(0,i.jsx)(t.code,{children:"IggySharedMut<>"})," which means that you can use a single instance of the client across multiple threads. Typically, it's a good idea to create a separate connection for producing and consuming, but it's not a requirement."]}),"\n",(0,i.jsx)(t.h2,{id:"producer",children:"Producer"}),"\n",(0,i.jsxs)(t.p,{children:["The producer is a high-level abstraction that allows you to send messages to the topic. It's quite simple to use and doesn't require you to handle the offsets, partitions or any other low-level details. To begin with, you can simply invoke ",(0,i.jsx)(t.code,{children:"client.producer()"})," to get the ",(0,i.jsx)(t.code,{children:"IggyProducerBuilder"})," allowing you to configure the producer. Let's take a look at the basic example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'let mut producer = client\n    .producer("my-stream", "my-topic")?\n    .direct(\n        DirectConfig::builder()\n            .batch_length(1000)\n            .linger_time(IggyDuration::from_str("5ms")?)\n            .build(),\n    )\n    .partitioning(Partitioning::balanced())\n    .build();\nproducer.init().await?;\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The code above will result in creating the producer that will try to send the messages in batches of 1000 every 5 milliseconds. You can choose between the ",(0,i.jsx)(t.code,{children:"direct"})," (an instant producer) or the ",(0,i.jsx)(t.code,{children:"background"})," (which will send the messages in the background by buffering them). The partitioning is set to ",(0,i.jsx)(t.code,{children:"balanced"})," which means that the producer will try to distribute the messages evenly across all the partitions. The ",(0,i.jsx)(t.code,{children:"init()"})," method is used to ensure that the producer is ready to send the messages by validating the existence of the stream, topic etc."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, you can use the ",(0,i.jsx)(t.code,{children:"send()"})," method to send the messages to the topic. The producer doesn't need to be a mutable reference, as it's only required during the initialization phase. Here's how you can send the messages:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'let messages = vec![IggyMessage::from_str("hello")?, IggyMessage::from_str("world")?];\nproducer.send(messages).await?\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Of course, you can provide the message headers, custom binary serialization etc. as it's the same ",(0,i.jsx)(t.code,{children:"Message"})," struct as the one used in the low-level API. The producer will take care of the rest, including the retries, partitioning, batching etc."]}),"\n",(0,i.jsx)(t.h2,{id:"consumer",children:"Consumer"}),"\n",(0,i.jsxs)(t.p,{children:["The consumer is a high-level abstraction that allows you to receive the messages from the topic. It's quite simple to use and doesn't require you to handle the offsets, partitions or any other low-level details. To begin with, you can simply invoke ",(0,i.jsx)(t.code,{children:"client.consumer()"})," to get the ",(0,i.jsx)(t.code,{children:"IggyConsumerBuilder"})," allowing you to configure the consumer. Let's take a look at the basic example:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'let mut consumer = client\n    .consumer_group("my-consumer-group", "my-stream", "my-topic")?\n    .auto_commit(AutoCommit::IntervalOrWhen(\n        IggyDuration::from_str("1s")?,\n        AutoCommitWhen::ConsumingAllMessages,\n    ))\n    .create_consumer_group_if_not_exists()\n    .auto_join_consumer_group()\n    .polling_strategy(PollingStrategy::next())\n    .poll_interval(IggyDuration::from_str("1ms")?)\n    .batch_length(1000)\n    .build();\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The code above will result in creating the consumer that will try to consume the messages in batches of 1000 every 1 millisecond. The auto-commit is set to commit the offset every second or when all the messages are consumed (fetched). The polling strategy is set to ",(0,i.jsx)(t.code,{children:"next"})," which means that the consumer will try to consume the next available message from the partition currently assigned to the consumer group (you can also invoke a regular ",(0,i.jsx)(t.code,{children:"consumer()"})," builder if you do not plan to use the consumer groups). The ",(0,i.jsx)(t.code,{children:"build()"})," method is used to create the consumer."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, you can use the ",(0,i.jsx)(t.code,{children:"next()"})," method to receive the messages from the topic. The consumer doesn't need to be a mutable reference, as it's only required during the initialization phase. The ",(0,i.jsx)(t.code,{children:"init()"})," is used to ensure that the consumer is ready to receive the messages by validating the existence of the stream, topic, consumer group etc.  Here's how you can consume the messages:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"consumer.init().await?;\n\n// Start consuming the messages\nwhile let Some(message) = consumer.next().await {\n    // Handle the message\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In order to use the async iterator extension, add ",(0,i.jsx)(t.a,{href:"https://crates.io/crates/futures-util",children:"futures-util"})," dependency."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);