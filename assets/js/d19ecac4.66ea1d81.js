"use strict";(self.webpackChunkiggy_website=self.webpackChunkiggy_website||[]).push([[933],{7128:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"connectors/connectors-sdk","title":"SDK","description":"SDK provides the commonly used structs and traits such as Sink and Source, along with the sinkconnector and sourceconnector macros to be used when developing connectors.","source":"@site/docs/connectors/sdk.md","sourceDirName":"connectors","slug":"/connectors/sdk","permalink":"/docs/connectors/sdk","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"connectors-sdk","slug":"/connectors/sdk","title":"SDK","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Runtime","permalink":"/docs/connectors/runtime"},"next":{"title":"Sink","permalink":"/docs/connectors/sink"}}');var s=o(4848),t=o(8453);const i={id:"connectors-sdk",slug:"/connectors/sdk",title:"SDK",sidebar_position:3},a=void 0,c={},d=[{value:"Protocol Buffers Support",id:"protocol-buffers-support",level:2},{value:"Configuration Example",id:"configuration-example",level:3},{value:"Key Configuration Options",id:"key-configuration-options",level:3},{value:"Source Configuration",id:"source-configuration",level:4},{value:"Transform Options",id:"transform-options",level:4},{value:"Supported Features",id:"supported-features",level:3},{value:"Programmatic Usage",id:"programmatic-usage",level:3},{value:"Dynamic Schema Loading",id:"dynamic-schema-loading",level:4},{value:"Schema Registry Integration",id:"schema-registry-integration",level:4},{value:"Creating Converters with Schema",id:"creating-converters-with-schema",level:4},{value:"Usage Notes",id:"usage-notes",level:3}];function l(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["SDK provides the commonly used structs and traits such as ",(0,s.jsx)(n.code,{children:"Sink"})," and ",(0,s.jsx)(n.code,{children:"Source"}),", along with the ",(0,s.jsx)(n.code,{children:"sink_connector"})," and ",(0,s.jsx)(n.code,{children:"source_connector"})," macros to be used when developing connectors."]}),"\n",(0,s.jsxs)(n.p,{children:["Moreover, it contains both, the ",(0,s.jsx)(n.code,{children:"decoders"})," and ",(0,s.jsx)(n.code,{children:"encoders"})," modules, implementing either ",(0,s.jsx)(n.code,{children:"StreamDecoder"})," or ",(0,s.jsx)(n.code,{children:"StreamEncoder"})," traits, which are used when consuming or producing data from/to Iggy streams."]}),"\n",(0,s.jsx)(n.p,{children:"SDK is WiP, and it'd certainly benefit from having the support of multiple format schemas, such as Protobuf, Avro, Flatbuffers etc. including decoding/encoding the data between the different formats (when applicable) and supporting the data transformations whenever possible (easy for JSON, but complex for Bincode for example)."}),"\n",(0,s.jsxs)(n.p,{children:["Last but not least, the different ",(0,s.jsx)(n.code,{children:"transforms"})," are available, to transform (add, update, delete etc.) the particular fields of the data being processed via external configuration. It's as simple as adding a new transform to the ",(0,s.jsx)(n.code,{children:"transforms"})," section of the particular connector configuration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[sources.random.transforms.add_fields]\nenabled = true\n\n[[sources.random.transforms.add_fields.fields]]\nkey = "message"\nvalue.static = "hello"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"protocol-buffers-support",children:"Protocol Buffers Support"}),"\n",(0,s.jsx)(n.p,{children:"The SDK includes support for Protocol Buffers (protobuf) format with both encoding and decoding capabilities. Protocol Buffers provide efficient serialization and are particularly useful for high-performance data streaming scenarios."}),"\n",(0,s.jsx)(n.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example configuration for using Protocol Buffers with Iggy connectors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[iggy]\naddress = "localhost:8090"\nusername = "iggy"\npassword = "iggy"\n\n[sources.protobuf_source]\nenabled = true\nname = "Protobuf Source"\npath = "target/release/libiggy_connector_protobuf_source"\n\n[[sources.protobuf_source.streams]]\nstream = "protobuf_stream"\ntopic = "protobuf_topic"\nschema = "proto"\nbatch_size = 1000\nsend_interval = "5ms"\n\n[sources.protobuf_source.config]\nschema_path = "schemas/message.proto"\nmessage_type = "com.example.Message"\nuse_any_wrapper = true\n\n[sinks.protobuf_sink]\nenabled = true\nname = "Protobuf Sink"\npath = "target/release/libiggy_connector_protobuf_sink"\n\n[[sinks.protobuf_sink.streams]]\nstream = "protobuf_stream"\ntopic = "protobuf_topic"\nschema = "proto"\n\n[[sinks.protobuf_sink.transforms]]\ntype = "proto_convert"\ntarget_format = "json"\npreserve_structure = true\n\nfield_mappings = { "old_field" = "new_field", "legacy_id" = "id" }\n\n[[sinks.protobuf_sink.transforms]]\ntype = "proto_convert"\ntarget_format = "proto"\npreserve_structure = false\n'})}),"\n",(0,s.jsx)(n.h3,{id:"key-configuration-options",children:"Key Configuration Options"}),"\n",(0,s.jsx)(n.h4,{id:"source-configuration",children:"Source Configuration"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"schema_path"})}),": Path to the ",(0,s.jsx)(n.code,{children:".proto"})," file containing message definitions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"message_type"})}),": Fully qualified name of the protobuf message type to use"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"use_any_wrapper"})}),": Whether to wrap messages in ",(0,s.jsx)(n.code,{children:"google.protobuf.Any"})," for type safety"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"transform-options",children:"Transform Options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"proto_convert"})}),": Transform for converting between protobuf and other formats"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"target_format"})}),": Target format for conversion (",(0,s.jsx)(n.code,{children:"json"}),", ",(0,s.jsx)(n.code,{children:"proto"}),", ",(0,s.jsx)(n.code,{children:"text"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"preserve_structure"})}),": Whether to preserve the original message structure during conversion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"field_mappings"})}),": Mapping of field names for transformation (e.g., ",(0,s.jsx)(n.code,{children:'"old_field" = "new_field"'}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"supported-features",children:"Supported Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encoding"}),": Convert JSON, Text, and Raw data to protobuf format"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Decoding"}),": Parse protobuf messages into JSON format with type information"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transforms"}),": Convert between protobuf and other formats (JSON, Text)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Field Mapping"}),": Transform field names during format conversion"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Any Wrapper"}),": Support for ",(0,s.jsx)(n.code,{children:"google.protobuf.Any"})," message wrapper"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"programmatic-usage",children:"Programmatic Usage"}),"\n",(0,s.jsx)(n.h4,{id:"dynamic-schema-loading",children:"Dynamic Schema Loading"}),"\n",(0,s.jsx)(n.p,{children:"You can load or reload schemas programmatically:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use iggy_connector_sdk::decoders::proto::{ProtoStreamDecoder, ProtoConfig};\nuse std::path::PathBuf;\n\nlet mut decoder = ProtoStreamDecoder::new(ProtoConfig {\n    schema_path: None,\n    use_any_wrapper: true,\n    ..Default::default()\n});\n\nlet config_with_schema = ProtoConfig {\n    schema_path: Some(PathBuf::from("schemas/user.proto")),\n    message_type: Some("com.example.User".to_string()),\n    ..Default::default()\n};\n\nmatch decoder.update_config(config_with_schema, true) {\n    Ok(()) => println!("Schema loaded successfully"),\n    Err(e) => eprintln!("Failed to load schema: {}", e),\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"schema-registry-integration",children:"Schema Registry Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use iggy_connector_sdk::encoders::proto::{ProtoStreamEncoder, ProtoEncoderConfig};\n\nlet mut encoder = ProtoStreamEncoder::new_with_config(ProtoEncoderConfig {\n    schema_registry_url: Some("http://schema-registry:8081".to_string()),\n    message_type: Some("com.example.Event".to_string()),\n    use_any_wrapper: false,\n    ..Default::default()\n});\n\nif let Err(e) = encoder.load_schema() {\n    eprintln!("Schema reload failed: {}", e);\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"creating-converters-with-schema",children:"Creating Converters with Schema"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use iggy_connector_sdk::transforms::proto_convert::{ProtoConvert, ProtoConvertConfig};\nuse iggy_connector_sdk::Schema;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nlet converter = ProtoConvert::new(ProtoConvertConfig {\n    source_format: Schema::Proto,\n    target_format: Schema::Json,\n    schema_path: Some(PathBuf::from("schemas/user.proto")),\n    message_type: Some("com.example.User".to_string()),\n    field_mappings: Some(HashMap::from([\n        ("user_id".to_string(), "id".to_string()),\n        ("full_name".to_string(), "name".to_string()),\n    ])),\n    ..ProtoConvertConfig::default()\n});\n\nlet mut converter_with_manual_loading = ProtoConvert::new(ProtoConvertConfig::default());\nif let Err(e) = converter_with_manual_loading.load_schema() {\n    eprintln!("Manual schema loading failed: {}", e);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-notes",children:"Usage Notes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Loading"}),": Schemas are loaded automatically when ",(0,s.jsx)(n.code,{children:"schema_path"})," or ",(0,s.jsx)(n.code,{children:"descriptor_set"})," is provided in config"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Manual Loading"}),": Use ",(0,s.jsx)(n.code,{children:"load_schema()"})," method for dynamic schema loading or reloading"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Schema loading errors are handled gracefully with fallback to Any wrapper mode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable Design"}),": Converters are created with fixed configuration - create new instances for different schemas"]}),"\n",(0,s.jsxs)(n.li,{children:["When ",(0,s.jsx)(n.code,{children:"use_any_wrapper"})," is enabled, messages are wrapped in ",(0,s.jsx)(n.code,{children:"google.protobuf.Any"})," for better type safety"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"proto_convert"})," transform can be used to convert protobuf messages to JSON for easier processing"]}),"\n",(0,s.jsx)(n.li,{children:"Field mappings allow you to rename fields during format conversion"}),"\n",(0,s.jsx)(n.li,{children:"Protocol Buffers provide efficient binary serialization compared to JSON"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>a});var r=o(6540);const s={},t=r.createContext(s);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);